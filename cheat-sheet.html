<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport"
        content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.10.0/styles/dracula.min.css">
  <link rel="stylesheet" href="./cheat-sheet.css">
  <script src="http://yandex.st/highlightjs/8.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
</head>
<body>


<article>
  <h1>Typescript Cheat-Sheet</h1>
  Typescript erweitert Javascript um einige nützliche Features wie Typen, Klassen und Interfaces. Die Syntax ähnelt
  stark der von klassischen Programmiersprachen, jedoch gibt es bei der Art und Weise wie Typescript die genannten
  Sprachmerkmale umsetzt wesentliche Unterschiede. In der folgenden Tabelle sind die Unterschiede am Beispiel von Java
  gegenübergestellt.

  <div class="code-block-container">
    <h3>Deklarationen</h3>
    Mit dem Schlüsselwort <i>let</i> lässt sich der Gültigkeitsbereich von Variablen auf Blöcke begrenzen, den
    sogenannten <i>block-scope</i>.
    Bei Java ist der Gültigkeitsbreich von lokal definierten Variablen immer block-scope.

    <div class="code-block">
      <pre><code class="javascript">
/* Typescript */
for (let i = 0; i < 10; i++) {
    console.log(i);
}
console.log(i); // cannot find name 'i'
      </code></pre>
    </div>

    Das Schlüsselwort <i>const</i> ist das äquivalent zu <i>final</i> in Java.
    Ein mit <i>const</i> bzw. <i>final</i> deklariertes Objekt darf nur <b>einmalig</b> zugewiesen werden.
    Bei komplexen Objekten ist die Änderung von Eigenschaften weiterhin möglich, das heißt sie sind <b>nicht</b> <i>immutable</i>.

    <div class="code-block">
      <pre><code class="java">
/* Java */
final User user = new User("Max");
user = someOtherUser; // Fehler
user.name = "moritz"; // OK
      </code></pre>

      <pre><code class="javascript">
/* Typescript */
const user : User = new User('Max');
user = someOtherUser; // Fehler
user.name = 'moritz'; // OK
      </code></pre>
    </div>

    <h3>Basisdatentypen</h3>
    <p>In typescript gibt es nur einen Datentyp für Zahlen: <i>number</i>.</p>
    <div class="code-block">
<pre><code class="java">
/* Java */
String name = "max";
boolean isTrue = true;
int zahl = 1;
float zahl = 1.1f;
int[] zahlen = [1,2,3];
</code></pre>
      <pre><code class="javascript">
/* Typescript */
name: string = 'max';
isTrue: boolean = true;
zahl: number = 1; // int, float, double...
zahlen: number[] = [1,2,3];
      </code></pre>
    </div>

    <h3>Template-Literale</h3>
    <p>asasa</p>
    <div class="code-block">
<pre><code class="java">
/* Java */
String name = "max";
String sentence = String.format("My Name is %s");
</code></pre>
      <pre><code class="javascript">
/* Typescript */
name: string = 'max';
let sentence = 'My Name is ${name}';
      </code></pre>
    </div>

    <h3>Funktionen</h3>
    <p>Innerhalb von <i>arrow functions</i> ist <i>this</i> nicht mehr kontextabhängig sondern <b>lexikalisch</b> (wie
      in Java).</p>
    <div class="code-block">
      <pre><code class="javascript">
/* Typescript */
let myObject = {
    name: 'max',
    add: () => {
        console.log(this.name);
    },
    subtract: function () {
        console.log(this.name);
    }
};
let add = myObject.add;
let subtract = myObject.subtract;
add(); // 'max'
subtract(); // Cannot read property 'name' of undefined
      </code></pre>
    </div>


    <h3>Collections</h3>
    <p>asasa</p>
    <div class="code-block">
<pre><code class="java">
</code></pre>

      <pre><code class="javascript">
      </code></pre>
    </div>

    <h3>Klassen</h3>
    <p></p>
    <div class="code-block">
<pre><code class="java">
  public class User {
    private String name;

    public User(String name){
        this.name = name;
    }

    public String getName(){
        return this.name;
    }
  }
</code></pre>

      <pre><code class="javascript">
class User {
  name: string;

  constructor(name: string) {
    this.name = name;
  }

  getName() {
    return this.name;
  }
}
      </code></pre>
    </div>

    <h3>Interfaces</h3>
    <p>asasa</p>
    <div class="code-block">
<pre><code class="java">
</code></pre>

      <pre><code class="javascript">
      </code></pre>
    </div>

    <h3>Abstrakte Klassen</h3>
    <p>Gleiche funktionsweise wie in Java.
      Abstrakte Klassen lassen sich nicht instanziieren und können im Gegensatz zu Interfaces Implementierungslogik enthalten.

    <div class="code-block">
<pre><code class="java">

</code></pre>

      <pre><code class="javascript">
/* Typescript - Declaration */
abstract class User {
    abstract getAge(): number;
}
let user = new User(); // Cannot create an instance of the abstract class 'User'.

/* Typescript - Usage */
class SpecificUser implements User {

  getAge(): number {
    return 10;
  }
}
      </code></pre>
    </div>

  </div>






  </div>


</article>


</body>
</html>
